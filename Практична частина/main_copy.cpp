#include <iostream>        // Підключаємо бібліотеку для роботи з потоками вводу/виводу
#include <stdexcept>       // Підключаємо бібліотеку для роботи з винятками

template <typename T>      // Оголошуємо параметризований шаблон з типом T
class LinkedList {         // Оголошуємо клас однозв'язного списку
private:                   // Приватна секція класу (недоступна ззовні)
    // Вузол списку - внутрішня структура для зберігання елементів
    struct Node {          // Оголошуємо структуру вузла
        T data;            // Дані, що зберігаються у вузлі
        Node* next;        // Покажчик на наступний вузол у списку
        
        // Конструктор вузла з ініціалізацією даних та обнуленням покажчика
        Node(const T& value) : data(value), next(nullptr) {}
    };
    
    Node* head;            // Покажчик на перший елемент списку
    Node* tail;            // Покажчик на останній елемент списку
    size_t size;           // Змінна для зберігання кількості елементів у списку
    
public:                     // Публічна секція класу (доступна ззовні)
    // Конструктор за замовчуванням - створює порожній список
    LinkedList() : head(nullptr), tail(nullptr), size(0) {}
    
    // Деструктор - автоматично викликається при знищенні об'єкта
    ~LinkedList() {            // Початок деструктора
        clear();               // Викликаємо функцію очищення списку
    }                          // Кінець деструктора
    
    // Конструктор копіювання - створює копію існуючого списку
    LinkedList(const LinkedList& other) : head(nullptr), tail(nullptr), size(0) {
        Node* current = other.head;  // Покажчик для проходження по оригінальному списку
        while (current != nullptr) { // Поки не дійшли до кінця списку
            pushBack(current->data); // Додаємо елемент в кінець нового списку
            current = current->next; // Переходимо до наступного елемента
        }                            // Кінець циклу копіювання
    }                                // Кінець конструктора копіювання
    
    // Оператор присвоєння - копіює дані з одного списку в інший
    LinkedList& operator=(const LinkedList& other) {
        if (this != &other) {        // Перевіряємо, чи не присвоюємо об'єкт сам собі
            clear();                 // Очищуємо поточний список
            Node* current = other.head; // Покажчик для проходження по оригінальному списку
            while (current != nullptr) { // Поки не дійшли до кінця списку
                pushBack(current->data); // Додаємо елемент в кінець поточного списку
                current = current->next; // Переходимо до наступного елемента
            }                            // Кінець циклу копіювання
        }                                // Кінець перевірки самоприсвоєння
        return *this;                    // Повертаємо посилання на поточний об'єкт
    }                                    // Кінець оператора присвоєння
    
    // Створення нового елемента на початку списку
    void pushFront(const T& value) {     // Функція додавання елемента на початок
        Node* newNode = new Node(value); // Створюємо новий вузол з переданим значенням
        
        if (head == nullptr) {           // Якщо список порожній
            head = tail = newNode;       // новий вузол стає і головою, і хвостом
        } else {                         // Якщо список не порожній
            newNode->next = head;        // новий вузол вказує на колишню голову
            head = newNode;              // новий вузол стає новою головою
        }                                // Кінець перевірки порожності списку
        size++;                          // Збільшуємо лічильник елементів на 1
    }                                    // Кінець функції pushFront
    
    // Вилучення першого елемента списку
    void popFront() {                                      // Функція видалення першого елемента
        if (head == nullptr) {                             // Якщо список порожній
            throw std::runtime_error("Список порожній");   // викидаємо виняток
        }                                                  // Кінець перевірки порожності
        
        Node* temp = head;               // Зберігаємо покажчик на перший елемент
        head = head->next;               // Переміщуємо голову на наступний елемент
        
        if (head == nullptr) {           // Якщо список став порожнім після видалення
            tail = nullptr;              // обнуляємо покажчик на хвіст
        }                                // Кінець перевірки на порожність після видалення
        
        delete temp;                     // Звільняємо пам'ять видаленого вузла
        size--;                          // Зменшуємо лічильник елементів на 1
    }                                    // Кінець функції popFront
    
    // Створення нового елемента в кінці списку
    void pushBack(const T& value) {      // Функція додавання елемента в кінець
        Node* newNode = new Node(value); // Створюємо новий вузол з переданим значенням
        
        if (tail == nullptr) {           // Якщо список порожній
            head = tail = newNode;       // новий вузол стає і головою, і хвостом
        } else {                         // Якщо список не порожній
            tail->next = newNode;        // колишній хвіст вказує на новий вузол
            tail = newNode;              // новий вузол стає новим хвостом
        }                                // Кінець перевірки порожності списку
        size++;                          // Збільшуємо лічильник елементів на 1
    }                                    // Кінець функції pushBack
    
    // Вилучення останнього елемента списку
    void popBack() {                                       // Функція видалення останнього елемента
        if (head == nullptr) {                             // Якщо список порожній
            throw std::runtime_error("Список порожній");   // викидаємо виняток
        }                                                  // Кінець перевірки порожності
        
        if (head == tail) {              // Якщо в списку тільки один елемент
            delete head;                 // видаляємо цей елемент
            head = tail = nullptr;       // обнуляємо обидва покажчики
        } else {                         // Якщо в списку більше одного елемента
            // Знаходимо передостанній елемент
            Node* current = head;        // Починаємо з голови списку
            while (current->next != tail) { // Поки не дійшли до передостаннього елемента
                current = current->next; // переходимо до наступного елемента
            }                            // Кінець пошуку передостаннього елемента
            
            delete tail;                 // Видаляємо останній елемент
            tail = current;              // Передостанній елемент стає новим хвостом
            tail->next = nullptr;        // Обнуляємо покажчик на наступний елемент
        }                                // Кінець перевірки кількості елементів
        size--;                          // Зменшуємо лічильник елементів на 1
    }                                    // Кінець функції popBack
    
    // Визначення кількості елементів списку
    size_t getSize() const {             // Функція повернення розміру списку (const - не змінює об'єкт)
        return size;                     // Повертаємо значення лічильника елементів
    }                                    // Кінець функції getSize
    
    // Перевірка чи список порожній
    bool isEmpty() const {               // Функція перевірки порожності списку (const - не змінює об'єкт)
        return size == 0;                // Повертаємо true, якщо розмір дорівнює 0
    }                                    // Кінець функції isEmpty
    
    // Отримання першого елемента (неконстантна версія)
    T& front() {                                         // Функція отримання посилання на перший елемент
        if (head == nullptr) {                           // Якщо список порожній
            throw std::runtime_error("Список порожній"); // викидаємо виняток
        }                                                // Кінець перевірки порожності
        return head->data;                               // Повертаємо посилання на дані першого елемента
    }                                                    // Кінець неконстантної версії front
    
    // Отримання першого елемента (константна версія)
    const T& front() const {                             // Константна функція отримання посилання на перший елемент
        if (head == nullptr) {                           // Якщо список порожній
            throw std::runtime_error("Список порожній"); // викидаємо виняток
        }                                                // Кінець перевірки порожності
        return head->data;                               // Повертаємо константне посилання на дані першого елемента
    }                                                    // Кінець константної версії front
    
    // Отримання останнього елемента (неконстантна версія)
    T& back() {                                          // Функція отримання посилання на останній елемент
        if (tail == nullptr) {                           // Якщо список порожній
            throw std::runtime_error("Список порожній"); // викидаємо виняток
        }                                                // Кінець перевірки порожності
        return tail->data;                               // Повертаємо посилання на дані останнього елемента
    }                                                    // Кінець неконстантної версії back
    
    // Отримання останнього елемента (константна версія)
    const T& back() const {                              // Константна функція отримання посилання на останній елемент
        if (tail == nullptr) {                           // Якщо список порожній
            throw std::runtime_error("Список порожній"); // викидаємо виняток
        }                                                // Кінець перевірки порожності
        return tail->data;                               // Повертаємо константне посилання на дані останнього елемента
    }                                                    // Кінець константної версії back
    
    // Очищення списку
    void clear() {                       // Функція очищення всього списку
        while (head != nullptr) {        // Поки список не порожній
            Node* temp = head;           // Зберігаємо покажчик на поточний перший елемент
            head = head->next;           // Переміщуємо голову на наступний елемент
            delete temp;                 // Видаляємо колишній перший елемент
        }                                // Кінець циклу видалення
        tail = nullptr;                  // Обнуляємо покажчик на хвіст
        size = 0;                        // Скидаємо лічильник елементів
    }                                    // Кінець функції clear
    
    // Виведення списку
    void print() const {                     // Функція виведення елементів списку (const - не змінює об'єкт)
        Node* current = head;                // Покажчик для проходження по списку, починаємо з голови
        std::cout << "[";                    // Виводимо відкриваючу квадратну дужку
        while (current != nullptr) {         // Поки не дійшли до кінця списку
            std::cout << current->data;      // Виводимо дані поточного елемента
            if (current->next != nullptr) {  // Якщо це не останній елемент
                std::cout << ", ";           // виводимо кому з пробілом
            }                                // Кінець перевірки на останній елемент
            current = current->next;         // Переходимо до наступного елемента
        }                                    // Кінець циклу виведення
        std::cout << "]" << std::endl;       // Виводимо закриваючу дужку та перехід на новий рядок
    }                                        // Кінець функції print
};                                           // Кінець класу LinkedList

// Демонстрація використання
int main() {                                                        // Головна функція програми
    std::cout << "=== Тестування LinkedList<int> ===" << std::endl; // Виводимо заголовок тестування
    
    LinkedList<int> intList;                                        // Створюємо список цілих чисел
    
    // Додавання елементів на початок
    std::cout << "Додавання на початок: 3, 2, 1" << std::endl;     // Повідомляємо про операцію
    intList.pushFront(3);                                           // Додаємо 3 на початок
    intList.pushFront(2);                                           // Додаємо 2 на початок (перед 3)
    intList.pushFront(1);                                           // Додаємо 1 на початок (перед 2)
    intList.print();                                                // Виводимо список
    std::cout << "Розмір: " << intList.getSize() << std::endl;     // Виводимо розмір списку
    
    // Додавання елементів в кінець
    std::cout << "\nДодавання в кінець: 4, 5" << std::endl;        // Повідомляємо про операцію
    intList.pushBack(4);                                            // Додаємо 4 в кінець
    intList.pushBack(5);                                            // Додаємо 5 в кінець
    intList.print();                                                // Виводимо список
    std::cout << "Розмір: " << intList.getSize() << std::endl;     // Виводимо розмір списку
    
    // Видалення з початку
    std::cout << "\nВидалення з початку" << std::endl;             // Повідомляємо про операцію
    intList.popFront();                                             // Видаляємо перший елемент
    intList.print();                                                // Виводимо список
    std::cout << "Розмір: " << intList.getSize() << std::endl;     // Виводимо розмір списку
    
    // Видалення з кінця
    std::cout << "\nВидалення з кінця" << std::endl;               // Повідомляємо про операцію
    intList.popBack();                                              // Видаляємо останній елемент
    intList.print();                                                // Виводимо список
    std::cout << "Розмір: " << intList.getSize() << std::endl;     // Виводимо розмір списку
    
    // Доступ до елементів
    std::cout << "\nПерший елемент: " << intList.front() << std::endl;  // Виводимо перший елемент
    std::cout << "Останній елемент: " << intList.back() << std::endl;   // Виводимо останній елемент
    
    std::cout << "\n=== Тестування LinkedList<std::string> ===" << std::endl; // Заголовок для тестування рядків
    
    LinkedList<std::string> stringList;                            // Створюємо список рядків
    
    stringList.pushBack("Hello");                                  // Додаємо "Hello" в кінець
    stringList.pushBack("World");                                  // Додаємо "World" в кінець
    stringList.pushFront("Hi");                                    // Додаємо "Hi" на початок
    stringList.print();                                            // Виводимо список рядків
    std::cout << "Розмір: " << stringList.getSize() << std::endl; // Виводимо розмір списку рядків
    
    // Тестування копіювання
    std::cout << "\n=== Тестування копіювання ===" << std::endl;  // Заголовок для тестування копіювання
    LinkedList<int> copyList = intList;                            // Створюємо копію списку
    std::cout << "Оригінал: ";                                     // Повідомляємо про вивід оригіналу
    intList.print();                                               // Виводимо оригінальний список
    std::cout << "Копія: ";                                        // Повідомляємо про вивід копії
    copyList.print();                                              // Виводимо скопійований список
    
    // Очищення
    std::cout << "\n=== Очищення списку ===" << std::endl;        // Заголовок для тестування очищення
    intList.clear();                                               // Очищуємо список
    std::cout << "Після очищення розмір: " << intList.getSize() << std::endl; // Виводимо розмір після очищення
    std::cout << "Список порожній: " << (intList.isEmpty() ? "Так" : "Ні") << std::endl; // Перевіряємо чи порожній
    
    return 0;                                                      // Повертаємо 0 (успішне завершення програми)
}                                                                  // Кінець головної функції